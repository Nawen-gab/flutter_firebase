import 'dart:async';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:flutter/material.dart';
import 'package:flutter_firebase/models/activity.dart';
import 'package:flutter_firebase/models/event.dart';
import 'package:flutter_firebase/models/participant.dart';
import 'package:flutter_firebase/models/user_m.dart';

class DatabaseService{

  final String? uid;
  DatabaseService({ this.uid });

  final CollectionReference personCollection = FirebaseFirestore.instance.collection('person');
  final CollectionReference eventCollection = FirebaseFirestore.instance.collection('event');

  Future updateUserData(String firstName, String lastName, bool admin) async {
    return await personCollection.doc(uid).set({
      'firstName': firstName,
      'lastName': lastName,
      'admin': admin,
    });
  }

  Future promoteToAdmin(String uid) async {
    return await personCollection.doc(uid).update({
      'admin': true,
    });
  }

  void deleteUser(String uid) async {
    await personCollection.doc(uid).delete();
  }

  Future createEventData(String title, String description, DateTime date, TimeOfDay start, TimeOfDay end, String location, bool isPublicEvent, List<Activity> activities) async {
    DocumentReference eventRef = await eventCollection.add({
      'title': title,
      'description': description,
      'date': date,//
      'start': start.hour.toString() + ':' + start.minute.toString(),
      'end': end.hour.toString() + ':' + end.minute.toString(),
      'location': location,
      'isPublicEvent': isPublicEvent,
      'creatorUid': this.uid
    });

    // Browse the list of activities and add them to the ‘activities’ sub-collection for this event
    for (Activity activity in activities) {
      DocumentReference activityRef = await eventRef.collection('activities').add({
        'title': activity.title ?? 'No Title',
        'description': activity.description ?? 'No Description',
        'start': activity.start != null ? activity.start!.hour.toString() + ':' + activity.start!.minute.toString() : 'No Start Time',
        'end': activity.end != null ? activity.end!.hour.toString() + ':' + activity.end!.minute.toString() : 'No End Time',
      });
      // Use the ID generated by Firestore as nameDoc
      await activityRef.update({
        'nameDoc': activityRef.id,  // Uses the ID generated by Firestore
      });
    }
  }

  Future updateEventData(String eventId, String title, String description, DateTime date, TimeOfDay start, TimeOfDay end, String location, bool isPublicEvent, List<Activity> activities) async {
    DocumentReference eventRef = eventCollection.doc(eventId);
    
    await eventRef.set({
      'title': title,
      'description': description,
      'date': date,//
      'start': start.hour.toString() + ':' + start.minute.toString(),
      'end': end.hour.toString() + ':' + end.minute.toString(),
      'location': location,
      'isPublicEvent': isPublicEvent,
      'creatorUid': uid
    });

    CollectionReference activitiesFirebase = eventCollection.doc(eventId).collection('activities');
    try {
      // Retrieve all the documents in the collection
      QuerySnapshot querySnapshot = await activitiesFirebase.get();
      
      // Browse each document
      if (querySnapshot.docs.isEmpty) {
        print('Aucun document trouvé');
      } else {
        querySnapshot.docs.forEach((doc) {
          bool isHere=false;
          for (Activity activity in activities){
            if(doc.id == activity.nameDoc){
              isHere = true;
            }
          }

          if(isHere==false){
            doc.reference.delete();
          }
        });
      }

      for (Activity activity in activities){
        if(activity.nameDoc == null){
          DocumentReference activityRef = await eventRef.collection('activities').add({
            'title': activity.title ?? 'No Title',
            'description': activity.description ?? 'No Description',
            'start': activity.start != null ? activity.start!.hour.toString() + ':' + activity.start!.minute.toString() : 'No Start Time',
            'end': activity.end != null ? activity.end!.hour.toString() + ':' + activity.end!.minute.toString() : 'No End Time',
          });
          // Use the ID generated by Firestore as nameDoc
          await activityRef.update({
            'nameDoc': activityRef.id,  // Uses the ID generated by Firestore
          });
        } else {
            await eventRef.collection('activities').doc(activity.nameDoc).update({
            'title': activity.title ?? 'No Title',
            'description': activity.description ?? 'No Description',
            'start': activity.start != null ? activity.start!.hour.toString() + ':' + activity.start!.minute.toString() : 'No Start Time',
            'end': activity.end != null ? activity.end!.hour.toString() + ':' + activity.end!.minute.toString() : 'No End Time',
          });
        }
      }
      
      eventRef.update({'update': true});
      print('event update--------------------------------------------------------------------------');
    } catch (e) {
      print("Erreur lors de la récupération des activités : $e");
    }
  }

  // Function for deleting an event and its associated activities
  Future<void> deleteEventWithActivities(String eventId) async {
    try {
      // Reference to event document
      DocumentReference eventRef = eventCollection.doc(eventId);
      // Retrieve the ‘activities’ sub-collection for this event
      QuerySnapshot activitiesSnapshot = await eventRef.collection('activities').get();
      // Delete each document in the ‘activities’ sub-collection
      for (DocumentSnapshot activityDoc in activitiesSnapshot.docs) {
        await activityDoc.reference.delete();
      }

      // Retrieve the ‘participants’ sub-collection for this event
      QuerySnapshot participantsSnapshot = await eventRef.collection('participants').get();
      // Delete each document in the ‘participants’ sub-collection
      for (DocumentSnapshot participantsDoc in participantsSnapshot.docs) {
        await participantsDoc.reference.delete();
      }
      // Delete the event after deleting all its activities
      await eventRef.delete();
    } catch (e) {
      print("Error deleting event : $e");
    }
  }

  // add a participant
  Future<void> addParticipant(String uid, String eventId, String firstName, String lastName, String email, int nbAdult, int nbChild, int nbNonMember, String food) async {
    // Browse the list of activities and add them to the ‘activities’ sub-collection for this event
    await eventCollection.doc(eventId).collection('participants').add({
      'uid': uid,
      'firstName': firstName,
      'lastName': lastName,
      'email': email,
      'nbAdult': nbAdult,
      'nbChild': nbChild,
      'nbNonMember': nbNonMember,
      'food': food,
    });
  }

  // event list from snapshot
  Stream<List<Event>> _eventListFromSnapshot(QuerySnapshot snapshot) async* {
    List<Event> events = [];
    for (var doc in snapshot.docs) {
      final data = doc.data() as Map<String, dynamic>;

      // Converting the date field (Firestore Timestamp) to DateTime
      DateTime? date = (data['date'] != null) ? (data['date'] as Timestamp).toDate() : null;

      // Converting the start and end fields to TimeOfDay
      TimeOfDay? start;
      TimeOfDay? end;

      if (data['start'] != null) {
        List<String> startSplit = (data['start'] as String).split(':');
        start = TimeOfDay(
          hour: int.parse(startSplit[0]),
          minute: int.parse(startSplit[1]),
        );
      }

      if (data['end'] != null) {
        List<String> endSplit = (data['end'] as String).split(':');
        end = TimeOfDay(
          hour: int.parse(endSplit[0]),
          minute: int.parse(endSplit[1]),
        );
      }

      List<Activity> activityStream = await _getActivitiesFromEvent(doc.reference);
      Stream<List<Participant>> participantStream = _getParticipantsFromEvent(doc.reference);

      List<Activity> activities = await activityStream;
      List<Participant> participants = await participantStream.first;

      Event event =  Event(
        nameDoc: doc.id,
        title: data['title'] ?? '',
        description: data['description'] ?? '',
        date: date,
        start: start,
        end: end,
        location: data['location'] ?? '',
        isPublicEvent: data['isPublicEvent'] ?? '',
        creatorUid: data['creatorUid'] ?? '',
        activities: activities,
        participants: participants
      );

      events.add(event);
    }

    // Return the complete list of events via a Stream
    yield events;
  }

 
  Future<List<Activity>> _getActivitiesFromEvent(DocumentReference eventRef) async {

    final activitySnapshot = await eventRef.collection('activities').get();

    List<Activity> listActivity = activitySnapshot.docs.map((activityDoc) {
      final activityData = activityDoc.data() as Map<String, dynamic>;

      // Conversion of start and end fields for each activity
      TimeOfDay? activityStart;
      TimeOfDay? activityEnd;

      if (activityData['start'] != null) {
        List<String> startSplit = (activityData['start'] as String).split(':');
        activityStart = TimeOfDay(
          hour: int.parse(startSplit[0]),
          minute: int.parse(startSplit[1]),
        );
      }

      if (activityData['end'] != null) {
        List<String> endSplit = (activityData['end'] as String).split(':');
        activityEnd = TimeOfDay(
          hour: int.parse(endSplit[0]),
          minute: int.parse(endSplit[1]),
        );
      }

      return Activity(
        nameDoc: activityDoc.id,
        title: activityData['title'] ?? 'No Title',
        description: activityData['description'] ?? 'No Description',
        start: activityStart,
        end: activityEnd,
      );
    }).toList();
    eventRef.update({'update': true});

    return listActivity;
  }
  
  Stream<List<Participant>> _getParticipantsFromEvent(DocumentReference eventRef) {
    return eventRef.collection('participants').snapshots().map((participantSnapshot){
      return participantSnapshot.docs.map((participantDoc) {
        final participantData = participantDoc.data() as Map<String, dynamic>;

        return Participant(
          uid: participantData['uid'] ?? 'no uid',
          firstName: participantData['firstName'] ?? 'No Fname',
          lastName: participantData['lastName'] ?? 'No Lname',
          email: participantData['email'] ?? 'No email',
          nbAdult: participantData['nbAdult'].toInt() ?? 0,
          nbChild: participantData['nbChild'].toInt() ?? 0,
          nbNonMember: participantData['nbNonMember'].toInt() ?? 0,
          food: participantData['food'] ?? 'No food',
        );
      }).toList();
    });
  }
  
  // userData from snapshot
  UserData _userDataFromSnapshot(DocumentSnapshot  snapshot){
    final data = snapshot.data() as Map<String, dynamic>?;
    return UserData(
      uid: uid,
      firstName: data?['firstName'] ?? '',
      lastName: data?['lastName'] ?? '',
      admin: data?['admin'] ?? null,// To recognise an unconnected person
    );
  }

  // userData from snapshot
  List<UserData> _listUserFromSnapshot(QuerySnapshot  snapshot) {
    return snapshot.docs.map((doc) {
    final data = doc.data() as Map<String, dynamic>?;
      return UserData(
        uid: doc.id,
        firstName: data?['firstName'] ?? '',
        lastName: data?['lastName'] ?? '',
        admin: data?['admin'] ?? null,// To recognise an unconnected person
      );
    }).toList();
  }

  Stream<List<Event>> get events {
    return eventCollection.snapshots().asyncMap((snapshot) async {
      return Future.wait(snapshot.docs.map((doc) async {
        final data = doc.data() as Map<String, dynamic>;

        // Converting the date field (Firestore Timestamp) to DateTime
        DateTime? date = (data['date'] != null) ? (data['date'] as Timestamp).toDate() : null;

        // Converting the start and end fields to TimeOfDay
        TimeOfDay? start;
        TimeOfDay? end;

        if (data['start'] != null) {
          List<String> startSplit = (data['start'] as String).split(':');
          start = TimeOfDay(hour: int.parse(startSplit[0]), minute: int.parse(startSplit[1]));
        }

        if (data['end'] != null) {
          List<String> endSplit = (data['end'] as String).split(':');
          end = TimeOfDay(hour: int.parse(endSplit[0]), minute: int.parse(endSplit[1]));
        }

        // Listening to activities and participants
        final activitiesStream = _getActivitiesFromEvent(doc.reference);
        final participantsStream = _getParticipantsFromEvent(doc.reference);

        // Retrieving lists of activities and participants
        List<Activity> activities = await activitiesStream;
        List<Participant> participants = await participantsStream.first;

        return Event(
          nameDoc: doc.id,
          title: data['title'] ?? '',
          description: data['description'] ?? '',
          date: date,
          start: start,
          end: end,
          location: data['location'] ?? '',
          isPublicEvent: data['isPublicEvent'] ?? false,
          creatorUid: data['creatorUid'] ?? '',
          activities: activities,
          participants: participants,
        );
      }).toList());
    });
  }


  // get user doc stream
  Stream<UserData> get userData {
    return personCollection.doc(uid).snapshots().map(_userDataFromSnapshot);
  }

  // get userList doc stream
  Stream<List<UserData>> get listUser {
    return personCollection.snapshots().map(_listUserFromSnapshot);
  }
}